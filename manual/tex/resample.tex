% ============================================================================
%  MCKL/manual/tex/resample.tex
% ----------------------------------------------------------------------------
%  MCKL: Monte Carlo Kernel Library
% ----------------------------------------------------------------------------
%  Copyright (c) 2013-2016, Yan Zhou
%  All rights reserved.
%
%  Redistribution and use in source and binary forms, with or without
%  modification, are permitted provided that the following conditions are met:
%
%    Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
%
%    Redistributions in binary form must reproduce the above copyright notice,
%    this list of conditions and the following disclaimer in the documentation
%    and/or other materials provided with the distribution.
%
%  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
%  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
%  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
%  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
%  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
%  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
%  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
%  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
%  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
%  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
%  POSSIBILITY OF SUCH DAMAGE.
% ============================================================================

\chapter{Resampling}
\label{chap:Resampling}

Given a particle system $\{W^i,X^i\}_{i=1}^N$, a resampling algorithm
generate a new system $\{\hat{W}^i, \hat{X}^i\}_{i=1}^M$ such that,
\begin{equation*}
  \Exp\Square[Big]{\sum_{i=1}^M{\hat{W}^i\varphi(\hat{X}^i)}} =
  \Exp\Square[Big]{\sum_{i=1}^N{W^i\varphi(X^i)}}
\end{equation*}
for test function $\varphi$. Regardless of other statistical properties, in
practice, such an algorithm can be decomposed into three steps,
\begin{enumerate}
  \item Generate the $N$-vector of replication numbers $\{r_i\}_{i=1}^N$, such
    that $\sum_{i=1}^N r_i = M$, and $0 \le r_i \le M$ for $i=1,\dots,N$.
  \item Generate the $M$-vector of indices $\{a_i\}_{i=1}^M$ such that
    $\sum_{i=1}^M \bbI_{\{j\}}(a_i) = r_j$, and $1 \le a_i \le N$ for $i =
    1,\dots,M$.
  \item Set $\hat{X}^i = X^{a_i}$ for $i = 1,\dots,M$.
\end{enumerate}
Given the results of the first step, the second step can be implemented with a
deterministic algorithm. And the final results will be determined up to
re-ordering. Therefore, it is the first step that determines the statistical
properties of the new particle system.

\section{Using resampling algorithms with samplers}
\label{sec:Using resampling algorithms with samplers}

Recall Section~\ref{sec:Sampler}, any object that is convertible to,
\begin{Verbatim}
  using eval_type =
      std::function<void(std::size_t, Particle<T> &)>;
\end{Verbatim}
can be added as a resampling evaluation object to a \verb|Sampler| object. The
library defines the following class template,
\begin{Verbatim}
  template <typename T>
  class ResampleEval;
\end{Verbatim}
that is compatible with the type above. It has a single constructor,
\begin{Verbatim}
  explicit ResampleEval(const eval_type &eval);
\end{Verbatim}
where \verb|eval_type| (not to be confused with the type of the same name in
\verb|Sampler|) is defined as the following,
\begin{Verbatim}
  using eval_type = std::function<void(
          std::size_t,
          std::size_t,
          typename Particle<T>::rng_type &,
          const double *,
          typename Particle<T>::size_type *)>;
\end{Verbatim}
An evaluation object that is convertible to the above will be used to generate
the $N$-vector of replication numbers $\{r_i\}_{i=1}^N$. When called, it will
be passed the following arguments,
\begin{Verbatim}
  eval(N, M, rng, w, r);
\end{Verbatim}
where $N$ is the original sample size, $M$ is the new sample size, \verb|rng|
is an \rng engine, \verb|w| is a pointer to the $N$-vector of normalized
weights, and output parameter \verb|r| points to the $N$-vector of replication
numbers. One can define function templates to avoid declaring these parameter
types explicitly. An object of the class \verb|ResampleEval| is convertible to
\verb|eval_type| of \verb|Sampler|, and can be added to a sampler as a
resampling evaluation object. Its operator will call the object passed to its
constructor to generate the $N$-vector of replication numbers
$\{r_i\}_{i=1}^N$. And it will generate the the $M$-vector of indices
$\{a_i\}_{i=1}^M$. And last, it will used the \verb|select| method of type
\verb|T| to duplicate states. The vector of indices generated by this operator
has the following property, in addition to those stated earlier at the
beginning of this chapter,
\begin{equation*}
  a_i = i \text{ if } r_i > 0 \text{ for } i = 1,\dots,\min\{N, M\}
\end{equation*}
In fact, the \verb|select| method of \verb|StateMatrix| in
Section~\ref{sec:State} makes the assumptions of this property about its input
indices.

\section{Builtin algorithms}
\label{sec:Builtin algorithms}

The library defines all algorithms discussed in \textcite{Douc:2005wa} and two
extensions to the those algorithms. Samplers can be constructed with builtin
schemes as seen in Section~\ref{sec:Sampler}. All builtin schemes are listed in
Table~\ref{tab:Resampling schemes}

\begin{table}
  \begin{tabularx}{\textwidth}{lL}
    \toprule
    \verb|ResampleScheme| & Algorithm \\
    \midrule
    \verb|Multinomial|        & Multinomial resampling             \\
    \verb|Stratified|         & Stratified resampling              \\
    \verb|Systematic|         & Systematic resampling              \\
    \verb|Residual|           & Residual resampling                \\
    \verb|ResidualStratified| & Stratified resampling on residuals \\
    \verb|ResidualSystematic| & Systematic resampling on residuals \\
    \bottomrule
  \end{tabularx}
  \caption{Resampling schemes}
  \label{tab:Resampling schemes}
\end{table}

\section{Implement new algorithms}
\label{sec:Implement new algorithms}

The library provides facilities for implementing new resampling algorithms.
The most common situation is that, an $M$-vector of random numbers on the
interval $[0, 1)$ is generated, say $\{u_i\}_{i=1}^M$. And the replication
numbers are generated through the inverse method, that is, $r_i = \sum_{j=1}^M
\bbI_{[v_{i-1},v_i)}(u_i)$, where $v_i = \sum_{j=1}^i W_i$, $v_0 = 0$. For
example, the Multinomial resampling algorithm is equivalent to
$\{u_i\}_{i=1}^M$ being i.i.d.\ standard uniform random numbers.

Alternatively, let $p_i = \Floor{MW_i}$, $q_i = MW_i - p_i$. One can perform
resampling on the residuals, using weights proportional to $\{q_i\}_{i=1}^N$.
The output size shall be $R = M - \sum_{i=1}^N p_i$. Let the replication
numbers be $\{s_i\}_{i=1}^N$, then $r_i = p_i + s_i$.

The library provides the following class template for implementing such
algorithms,
\begin{Verbatim}
  template <typename U01SeqType, bool Residual>
  class ResampleAlgorithm;
\end{Verbatim}
where \verb|U01SeqType| will be discussed later. The second parameter
\verb|Residual| determines if the resampling shall be applied to residuals.

The template parameter \verb|U01SeqType| shall be a class with default
constructor and defines the an \verb|operator()| that is compatible with the
following,
\begin{Verbatim}
  template <typename RNGType>
  void operator()(RNGType &rng, std::size_t N, double *r);
\end{Verbatim}
which will generate $N$ random numbers within $[0, 1)$, say $\{u_i\}_{i=1}^M$,
such that $u_1 \le u_2 \le \dots \le u_M$.

An obvious method is to generate the random numbers first and then sort them.
However, no sorting algorithm has linear cost, while it is possible to generate
such an ordered sequence with cost $\calO(M)$ using order statistics. The
library defines three such sequences. The first is equivalent to sorted i.i.d.\
random numbers,
\begin{Verbatim}
  class U01SequenceSorted;
\end{Verbatim}
The second is the stratified sequence, $U_i = \delta V_i + i$ for $i =
1,\dots,M$, where $\delta = 1 / M$ and $\{V_i\}_{i=1}^M$ are i.i.d.\ standard
uniform random variables,
\begin{Verbatim}
  class U01SequenceStratified;
\end{Verbatim}
The last is the systematic sequence, $U_i = \delta U + i$ for $i = 1,\dots,M$,
where $\delta = 1 / M$ and $U$ is a standard uniform random variable,
\begin{Verbatim}
  class U01SequenceSysmatic;
\end{Verbatim}
All builtin resampling algorithms are implemented using these sequences. For
example,
\begin{Verbatim}
  using ResampleMultinomial =
      ResampleAlgorithm<U01SequenceSorted, false>;
  using ResampleResidual =
      ResampleAlgorithm<U01SequenceSorted, true>;
\end{Verbatim}
If the user can define a new ordered random sequence, either through sorting or
otherwise, then using the \verb|ResampleAlgorithm| template, a new resampling
algorithm can easily be implemented. Note that, the algorithm implemented by
the class template \verb|ResampleAlgorithms| always has a cost $\calO(N + M)$,
unless the random sequence has a greater cost. Usually, $N$ and $M$ are at the
same order, and thus the cost is $\calO(N)$.
